# Testing

## Unit tests

### General

Unit tests for the Java application have been done using JUnit. You can view the latest Jacoco test report [here](https://nakkekakke.github.io/rummy-ai/index/). 

Overall, the unit testing of the application is looking pretty decent with line coverage being over 80%. Also, a lot of manual testing has been done to make sure the application functions properly. Below are short explanations for the testing of some key classes of this application.

### State

The class State being the central part of the game logic, it's unit testing is pretty good overall with line coverage being at 88%. Some functions like cloneState() and cloneAndRandomizeState() are hard to test because of the way I made them, so their coverage is not very good. However, I have tested them manually quite extensively and they work just fine.

### Node

The coverage for Node looks much worse than what it actually is. This is because it has some methods used for printing that haven't been tested. Those methods are only for debugging and don't affect the functionality of the program at all. Without them the class would basically have 100% test coverage.

### ISMCTS

This class has high test coverage percentages. Some edge cases haven't been thoroughly tested, but they seem to work fine. This class is also hard to test thoroughly because of how it is structured and how the algorithm works. Most of the manual testing of this project went to this particular class.

### Move and meld classes

All of the move and meld classes seem to have suboptimal test coverage, however, this is because the hashCode and toString methods haven't been unit tested. All of the hashCode methods have been autogenerated by NetBeans and seem to work fine.

## Performance tests

The performance tests are covered [here](https://github.com/nakkekakke/rummy-ai/blob/master/documentation/implementation_document.md#performance)
